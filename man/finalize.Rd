% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/finalize.R
\name{finalize}
\alias{finalize}
\alias{finalize.list}
\alias{finalize.param}
\alias{get_p}
\alias{get_log_p}
\alias{get_n_frac}
\alias{get_n_frac_range}
\alias{get_n}
\alias{get_rbf_range}
\alias{get_batch_sizes}
\title{Functions to finalize data-specific parameter ranges}
\usage{
finalize(object, ...)

\method{finalize}{list}(object, x, force = TRUE, ...)

\method{finalize}{param}(object, x, force = TRUE, ...)

get_p(object, x, log_vals = FALSE, ...)

get_log_p(object, x, ...)

get_n_frac(object, x, log_vals = FALSE, frac = 1/3, ...)

get_n_frac_range(object, x, log_vals = FALSE, frac = c(1/10, 5/10),
  ...)

get_n(object, x, log_vals = FALSE, ...)

get_rbf_range(object, x, seed = sample.int(10^5, 1), ...)

get_batch_sizes(object, x, frac = c(1/10, 1/3), ...)
}
\arguments{
\item{object}{A \code{param} object or list.}

\item{...}{Other arguments to pass to \link[kernlab:sigest]{kernlab::sigest}.}

\item{x}{The predictor data. In some cases (see below) this should only
include numeric data.}

\item{force}{A single logical that indicates that, even if the parameter
object is complete, should it update the ranges anyway?}

\item{log_vals}{A logical: should the ranges be set on the log10 scale?}

\item{frac}{A double for the fraction of the data to be used for the upper
bound. For \code{get_n_frac_range} and \code{get_batch_sizes}, two fractional values
are required.}

\item{seed}{An integer to control the randomness of the calculations.}
}
\value{
An updated \code{param} object.
}
\description{
These functions take a parameter object and modify the unknown parts of
ranges based on simple heuristics.
}
\details{
\code{finalize} runes the embedded finalization code contained in the \code{param}
object and returns the updated version.

The "get" helper functions are designed to be used with the pipe and update
the parameter object in-place.

\code{get_p} and \code{get_log_p} set the upper value of the range to be the number of
columns in the data (on the natural and log10 scale, respectively). \code{get_n}
and \code{get_n_frac} set the upper value to be a value that uses the number of
rows.

\code{get_rbf_range} sets both bounds based on the heuristic defined in
\link[kernlab:sigest]{kernlab::sigest}. It requires that all columns in \code{x} be numeric.
}
\examples{
library(dplyr)
car_pred <- mtcars \%>\% select(-mpg)

# Needs an upper bound
mtry
finalize(mtry, car_pred)

# Nothing to do here since no unknowns
penalty
finalize(penalty, car_pred)

library(kernlab)
library(tibble)
library(purrr)

params <- 
  tribble(
     ~parameter,   ~object,
         "mtry",      mtry, 
    "num_terms", num_terms, 
    "rbf_sigma", rbf_sigma
  ) 
params
  
# Note that `rbf_sigma` has a default range that does not need to be
# finalized but will be changed if used in the function:
complete_params <- 
  params \%>\%
  mutate(object = map(object, finalize, car_pred))
complete_params

params \%>\% dplyr::filter(parameter == "rbf_sigma") \%>\% pull(object)
complete_params \%>\% dplyr::filter(parameter == "rbf_sigma") \%>\% pull(object)

}
